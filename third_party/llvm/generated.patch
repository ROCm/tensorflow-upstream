Auto generated patch. Do not edit or delete it, even if empty.
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/BuiltinsRISCVVector.def b/clang/include/clang/Basic/BuiltinsRISCVVector.def
--- a/clang/include/clang/Basic/BuiltinsRISCVVector.def
+++ b/clang/include/clang/Basic/BuiltinsRISCVVector.def
@@ -16,6 +16,7 @@
 #endif
 
 #include "clang/Basic/riscv_vector_builtins.inc"
+#include "clang/Basic/riscv_sifive_vector_builtins.inc"
 
 #undef BUILTIN
 #undef TARGET_BUILTIN
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/CMakeLists.txt b/clang/include/clang/Basic/CMakeLists.txt
--- a/clang/include/clang/Basic/CMakeLists.txt
+++ b/clang/include/clang/Basic/CMakeLists.txt
@@ -93,3 +93,12 @@
 clang_tablegen(riscv_vector_builtin_sema.inc -gen-riscv-vector-builtin-sema
   SOURCE riscv_vector.td
   TARGET ClangRISCVVectorBuiltinSema)
+clang_tablegen(riscv_sifive_vector_builtins.inc -gen-riscv-sifive-vector-builtins
+  SOURCE riscv_sifive_vector.td
+  TARGET ClangRISCVSiFiveVectorBuiltins)
+clang_tablegen(riscv_sifive_vector_builtin_cg.inc -gen-riscv-sifive-vector-builtin-codegen
+  SOURCE riscv_sifive_vector.td
+  TARGET ClangRISCVSiFiveVectorBuiltinCG)
+clang_tablegen(riscv_sifive_vector_builtin_sema.inc -gen-riscv-sifive-vector-builtin-sema
+  SOURCE riscv_sifive_vector.td
+  TARGET ClangRISCVSiFiveVectorBuiltinSema)
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/riscv_sifive_vector.td b/clang/include/clang/Basic/riscv_sifive_vector.td
--- a/clang/include/clang/Basic/riscv_sifive_vector.td
+++ b/clang/include/clang/Basic/riscv_sifive_vector.td
@@ -12,6 +12,8 @@
 //
 //===----------------------------------------------------------------------===//
 
+include "riscv_vector_common.td"
+
 //===----------------------------------------------------------------------===//
 // Instruction definitions
 //===----------------------------------------------------------------------===//
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/riscv_vector.td b/clang/include/clang/Basic/riscv_vector.td
--- a/clang/include/clang/Basic/riscv_vector.td
+++ b/clang/include/clang/Basic/riscv_vector.td
@@ -12,233 +12,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-//===----------------------------------------------------------------------===//
-// Instruction definitions
-//===----------------------------------------------------------------------===//
-// Each record of the class RVVBuiltin defines a collection of builtins (i.e.
-// "def vadd : RVVBuiltin" will be used to define things like "vadd_vv_i32m1",
-// "vadd_vv_i32m2", etc).
-//
-// The elements of this collection are defined by an instantiation process the
-// range of which is specified by the cross product of the LMUL attribute and
-// every element in the attribute TypeRange. By default builtins have LMUL = [1,
-// 2, 4, 8, 1/2, 1/4, 1/8] so the process is repeated 7 times. In tablegen we
-// use the Log2LMUL [0, 1, 2, 3, -1, -2, -3] to represent the LMUL.
-//
-// LMUL represents the fact that the types of values used by that builtin are
-// values generated by instructions that are executed under that LMUL. However,
-// this does not mean the builtin is necessarily lowered into an instruction
-// that executes under the specified LMUL. An example where this happens are
-// loads and stores of masks. A mask like `vbool8_t` can be generated, for
-// instance, by comparing two `__rvv_int8m1_t` (this is LMUL=1) or comparing two
-// `__rvv_int16m2_t` (this is LMUL=2). The actual load or store, however, will
-// be performed under LMUL=1 because mask registers are not grouped.
-//
-// TypeRange is a non-empty sequence of basic types:
-//
-//   c: int8_t (i8)
-//   s: int16_t (i16)
-//   i: int32_t (i32)
-//   l: int64_t (i64)
-//   x: float16_t (half)
-//   f: float32_t (float)
-//   d: float64_t (double)
-//
-// This way, given an LMUL, a record with a TypeRange "sil" will cause the
-// definition of 3 builtins. Each type "t" in the TypeRange (in this example
-// they are int16_t, int32_t, int64_t) is used as a parameter that drives the
-// definition of that particular builtin (for the given LMUL).
-//
-// During the instantiation, types can be transformed or modified using type
-// transformers. Given a type "t" the following primitive type transformers can
-// be applied to it to yield another type.
-//
-//   e: type of "t" as is (identity)
-//   v: computes a vector type whose element type is "t" for the current LMUL
-//   w: computes a vector type identical to what 'v' computes except for the
-//      element type which is twice as wide as the element type of 'v'
-//   q: computes a vector type identical to what 'v' computes except for the
-//      element type which is four times as wide as the element type of 'v'
-//   o: computes a vector type identical to what 'v' computes except for the
-//      element type which is eight times as wide as the element type of 'v'
-//   m: computes a vector type identical to what 'v' computes except for the
-//      element type which is bool
-//   0: void type, ignores "t"
-//   z: size_t, ignores "t"
-//   t: ptrdiff_t, ignores "t"
-//   u: unsigned long, ignores "t"
-//   l: long, ignores "t"
-//
-// So for instance if t is "i", i.e. int, then "e" will yield int again. "v"
-// will yield an RVV vector type (assume LMUL=1), so __rvv_int32m1_t.
-// Accordingly "w" would yield __rvv_int64m2_t.
-//
-// A type transformer can be prefixed by other non-primitive type transformers.
-//
-//   P: constructs a pointer to the current type
-//   C: adds const to the type
-//   K: requires the integer type to be a constant expression
-//   U: given an integer type or vector type, computes its unsigned variant
-//   I: given a vector type, compute the vector type with integer type
-//      elements of the same width
-//   F: given a vector type, compute the vector type with floating-point type
-//      elements of the same width
-//   S: given a vector type, computes its equivalent one for LMUL=1. This is a
-//      no-op if the vector was already LMUL=1
-//   (Log2EEW:Value): Log2EEW value could be 3/4/5/6 (8/16/32/64), given a
-//      vector type (SEW and LMUL) and EEW (8/16/32/64), computes its
-//      equivalent integer vector type with EEW and corresponding ELMUL (elmul =
-//      (eew/sew) * lmul). For example, vector type is __rvv_float16m4
-//      (SEW=16, LMUL=4) and Log2EEW is 3 (EEW=8), and then equivalent vector
-//      type is __rvv_uint8m2_t (elmul=(8/16)*4 = 2). Ignore to define a new
-//      builtins if its equivalent type has illegal lmul.
-//   (FixedSEW:Value): Given a vector type (SEW and LMUL), and computes another
-//      vector type which only changed SEW as given value. Ignore to define a new
-//      builtin if its equivalent type has illegal lmul or the SEW does not changed.
-//   (SFixedLog2LMUL:Value): Smaller Fixed Log2LMUL. Given a vector type (SEW
-//      and LMUL), and computes another vector type which only changed LMUL as
-//      given value. The new LMUL should be smaller than the old one. Ignore to
-//      define a new builtin if its equivalent type has illegal lmul.
-//   (LFixedLog2LMUL:Value): Larger Fixed Log2LMUL. Given a vector type (SEW
-//      and LMUL), and computes another vector type which only changed LMUL as
-//      given value. The new LMUL should be larger than the old one. Ignore to
-//      define a new builtin if its equivalent type has illegal lmul.
-//
-// Following with the example above, if t is "i", then "Ue" will yield unsigned
-// int and "Fv" will yield __rvv_float32m1_t (again assuming LMUL=1), Fw would
-// yield __rvv_float64m2_t, etc.
-//
-// Each builtin is then defined by applying each type in TypeRange against the
-// sequence of type transformers described in Suffix and Prototype.
-//
-// The name of the builtin is defined by the Name attribute (which defaults to
-// the name of the class) appended (separated with an underscore) the Suffix
-// attribute. For instance with Name="foo", Suffix = "v" and TypeRange = "il",
-// the builtin generated will be __builtin_rvv_foo_i32m1 and
-// __builtin_rvv_foo_i64m1 (under LMUL=1). If Suffix contains more than one
-// type transformer (say "vv") each of the types is separated with an
-// underscore as in "__builtin_rvv_foo_i32m1_i32m1".
-//
-// The C/C++ prototype of the builtin is defined by the Prototype attribute.
-// Prototype is a non-empty sequence of type transformers, the first of which
-// is the return type of the builtin and the rest are the parameters of the
-// builtin, in order. For instance if Prototype is "wvv" and TypeRange is "si"
-// a first builtin will have type
-// __rvv_int32m2_t (__rvv_int16m1_t, __rvv_int16m1_t) and the second builtin
-// will have type __rvv_int64m2_t (__rvv_int32m1_t, __rvv_int32m1_t) (again
-// under LMUL=1).
-//
-// There are a number of attributes that are used to constraint the number and
-// shape of the builtins generated. Refer to the comments below for them.
-
-class PolicyScheme<int val>{
-  int Value = val;
-}
-def NonePolicy : PolicyScheme<0>;
-def HasPassthruOperand : PolicyScheme<1>;
-def HasPolicyOperand : PolicyScheme<2>;
-
-class RVVBuiltin<string suffix, string prototype, string type_range,
-                 string overloaded_suffix = ""> {
-  // Base name that will be prepended in __builtin_rvv_ and appended the
-  // computed Suffix.
-  string Name = NAME;
-
-  // If not empty, each instantiated builtin will have this appended after an
-  // underscore (_). It is instantiated like Prototype.
-  string Suffix = suffix;
-
-  // If empty, default OverloadedName is sub string of `Name` which end of first
-  // '_'. For example, the default overloaded name  is `vadd` for Name `vadd_vv`.
-  // It's used for describe some special naming cases.
-  string OverloadedName = "";
-
-  // If not empty, each OverloadedName will have this appended after an
-  // underscore (_). It is instantiated like Prototype.
-  string OverloadedSuffix = overloaded_suffix;
-
-  // The different variants of the builtin, parameterised with a type.
-  string TypeRange = type_range;
-
-  // We use each type described in TypeRange and LMUL with prototype to
-  // instantiate a specific element of the set of builtins being defined.
-  // Prototype attribute defines the C/C++ prototype of the builtin. It is a
-  // non-empty sequence of type transformers, the first of which is the return
-  // type of the builtin and the rest are the parameters of the builtin, in
-  // order. For instance if Prototype is "wvv", TypeRange is "si" and LMUL=1, a
-  // first builtin will have type
-  // __rvv_int32m2_t (__rvv_int16m1_t, __rvv_int16m1_t), and the second builtin
-  // will have type __rvv_int64m2_t (__rvv_int32m1_t, __rvv_int32m1_t).
-  string Prototype = prototype;
-
-  // This builtin has a masked form.
-  bit HasMasked = true;
-
-  // If HasMasked, this flag states that this builtin has a maskedoff operand. It
-  // is always the first operand in builtin and IR intrinsic.
-  bit HasMaskedOffOperand = true;
-
-  // This builtin has a granted vector length parameter.
-  bit HasVL = true;
-
-  // The policy scheme for masked intrinsic IR.
-  // It could be NonePolicy or HasPolicyOperand.
-  // HasPolicyOperand: Has a policy operand. 0 is tail and mask undisturbed, 1 is
-  // tail agnostic, 2 is mask undisturbed, and 3 is tail and mask agnostic. The
-  // policy operand is located at the last position.
-  PolicyScheme MaskedPolicyScheme = HasPolicyOperand;
-
-  // The policy scheme for unmasked intrinsic IR.
-  // It could be NonePolicy, HasPassthruOperand or HasPolicyOperand.
-  // HasPassthruOperand: Has a passthru operand to decide tail policy. If it is
-  // poison, tail policy is tail agnostic, otherwise policy is tail undisturbed.
-  // HasPolicyOperand: Has a policy operand. 1 is tail agnostic and 0 is tail
-  // undisturbed.
-  PolicyScheme UnMaskedPolicyScheme = NonePolicy;
-
-  // This builtin support tail agnostic and undisturbed policy.
-  bit HasTailPolicy = true;
-  // This builtin support mask agnostic and undisturbed policy.
-  bit HasMaskPolicy = true;
-
-  // This builtin prototype with TA or TAMA policy could not support overloading
-  // API. Other policy intrinsic functions would support overloading API with
-  // suffix `_tu`, `tumu`, `tuma`, `tamu` and `tama`.
-  bit SupportOverloading = true;
-
-  // This builtin is valid for the given Log2LMULs.
-  list<int> Log2LMUL = [0, 1, 2, 3, -1, -2, -3];
-
-  // Manual code in clang codegen riscv_vector_builtin_cg.inc
-  code ManualCodegen = [{}];
-
-  // When emit the automatic clang codegen, it describes what types we have to use
-  // to obtain the specific LLVM intrinsic. -1 means the return type, otherwise,
-  // k >= 0 meaning the k-th operand (counting from zero) of the codegen'd
-  // parameter of the unmasked version. k can't be the mask operand's position.
-  list<int> IntrinsicTypes = [];
-
-  // If these names are not empty, this is the ID of the LLVM intrinsic
-  // we want to lower to.
-  string IRName = NAME;
-
-  // If HasMasked, this is the ID of the LLVM intrinsic we want to lower to.
-  string MaskedIRName = NAME #"_mask";
-
-  // Use clang_builtin_alias to save the number of builtins.
-  bit HasBuiltinAlias = true;
-
-  // Features required to enable for this builtin.
-  list<string> RequiredFeatures = [];
-
-  // Number of fields for Load/Store Segment instructions.
-  int NF = 1;
-}
-
-// This is the code emitted in the header.
-class RVVHeader {
-  code HeaderCode;
-}
+include "riscv_vector_common.td"
 
 //===----------------------------------------------------------------------===//
 // Basic classes with automatic codegen.
@@ -2374,5 +2148,3 @@
     }
   }
 }
-
-include "riscv_sifive_vector.td"
diff -ruN --strip-trailing-cr a/clang/include/clang/Basic/riscv_vector_common.td b/clang/include/clang/Basic/riscv_vector_common.td
--- a/clang/include/clang/Basic/riscv_vector_common.td
+++ b/clang/include/clang/Basic/riscv_vector_common.td
@@ -0,0 +1,239 @@
+//==------ riscv_vector_common.td - RISC-V V-ext builtin class ------------===//
+//
+//  Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+//  See https://llvm.org/LICENSE.txt for license information.
+//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines RVV builtin base class for RISC-V V-extension.
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Instruction definitions
+//===----------------------------------------------------------------------===//
+// Each record of the class RVVBuiltin defines a collection of builtins (i.e.
+// "def vadd : RVVBuiltin" will be used to define things like "vadd_vv_i32m1",
+// "vadd_vv_i32m2", etc).
+//
+// The elements of this collection are defined by an instantiation process the
+// range of which is specified by the cross product of the LMUL attribute and
+// every element in the attribute TypeRange. By default builtins have LMUL = [1,
+// 2, 4, 8, 1/2, 1/4, 1/8] so the process is repeated 7 times. In tablegen we
+// use the Log2LMUL [0, 1, 2, 3, -1, -2, -3] to represent the LMUL.
+//
+// LMUL represents the fact that the types of values used by that builtin are
+// values generated by instructions that are executed under that LMUL. However,
+// this does not mean the builtin is necessarily lowered into an instruction
+// that executes under the specified LMUL. An example where this happens are
+// loads and stores of masks. A mask like `vbool8_t` can be generated, for
+// instance, by comparing two `__rvv_int8m1_t` (this is LMUL=1) or comparing two
+// `__rvv_int16m2_t` (this is LMUL=2). The actual load or store, however, will
+// be performed under LMUL=1 because mask registers are not grouped.
+//
+// TypeRange is a non-empty sequence of basic types:
+//
+//   c: int8_t (i8)
+//   s: int16_t (i16)
+//   i: int32_t (i32)
+//   l: int64_t (i64)
+//   x: float16_t (half)
+//   f: float32_t (float)
+//   d: float64_t (double)
+//
+// This way, given an LMUL, a record with a TypeRange "sil" will cause the
+// definition of 3 builtins. Each type "t" in the TypeRange (in this example
+// they are int16_t, int32_t, int64_t) is used as a parameter that drives the
+// definition of that particular builtin (for the given LMUL).
+//
+// During the instantiation, types can be transformed or modified using type
+// transformers. Given a type "t" the following primitive type transformers can
+// be applied to it to yield another type.
+//
+//   e: type of "t" as is (identity)
+//   v: computes a vector type whose element type is "t" for the current LMUL
+//   w: computes a vector type identical to what 'v' computes except for the
+//      element type which is twice as wide as the element type of 'v'
+//   q: computes a vector type identical to what 'v' computes except for the
+//      element type which is four times as wide as the element type of 'v'
+//   o: computes a vector type identical to what 'v' computes except for the
+//      element type which is eight times as wide as the element type of 'v'
+//   m: computes a vector type identical to what 'v' computes except for the
+//      element type which is bool
+//   0: void type, ignores "t"
+//   z: size_t, ignores "t"
+//   t: ptrdiff_t, ignores "t"
+//   u: unsigned long, ignores "t"
+//   l: long, ignores "t"
+//
+// So for instance if t is "i", i.e. int, then "e" will yield int again. "v"
+// will yield an RVV vector type (assume LMUL=1), so __rvv_int32m1_t.
+// Accordingly "w" would yield __rvv_int64m2_t.
+//
+// A type transformer can be prefixed by other non-primitive type transformers.
+//
+//   P: constructs a pointer to the current type
+//   C: adds const to the type
+//   K: requires the integer type to be a constant expression
+//   U: given an integer type or vector type, computes its unsigned variant
+//   I: given a vector type, compute the vector type with integer type
+//      elements of the same width
+//   F: given a vector type, compute the vector type with floating-point type
+//      elements of the same width
+//   S: given a vector type, computes its equivalent one for LMUL=1. This is a
+//      no-op if the vector was already LMUL=1
+//   (Log2EEW:Value): Log2EEW value could be 3/4/5/6 (8/16/32/64), given a
+//      vector type (SEW and LMUL) and EEW (8/16/32/64), computes its
+//      equivalent integer vector type with EEW and corresponding ELMUL (elmul =
+//      (eew/sew) * lmul). For example, vector type is __rvv_float16m4
+//      (SEW=16, LMUL=4) and Log2EEW is 3 (EEW=8), and then equivalent vector
+//      type is __rvv_uint8m2_t (elmul=(8/16)*4 = 2). Ignore to define a new
+//      builtins if its equivalent type has illegal lmul.
+//   (FixedSEW:Value): Given a vector type (SEW and LMUL), and computes another
+//      vector type which only changed SEW as given value. Ignore to define a new
+//      builtin if its equivalent type has illegal lmul or the SEW does not changed.
+//   (SFixedLog2LMUL:Value): Smaller Fixed Log2LMUL. Given a vector type (SEW
+//      and LMUL), and computes another vector type which only changed LMUL as
+//      given value. The new LMUL should be smaller than the old one. Ignore to
+//      define a new builtin if its equivalent type has illegal lmul.
+//   (LFixedLog2LMUL:Value): Larger Fixed Log2LMUL. Given a vector type (SEW
+//      and LMUL), and computes another vector type which only changed LMUL as
+//      given value. The new LMUL should be larger than the old one. Ignore to
+//      define a new builtin if its equivalent type has illegal lmul.
+//
+// Following with the example above, if t is "i", then "Ue" will yield unsigned
+// int and "Fv" will yield __rvv_float32m1_t (again assuming LMUL=1), Fw would
+// yield __rvv_float64m2_t, etc.
+//
+// Each builtin is then defined by applying each type in TypeRange against the
+// sequence of type transformers described in Suffix and Prototype.
+//
+// The name of the builtin is defined by the Name attribute (which defaults to
+// the name of the class) appended (separated with an underscore) the Suffix
+// attribute. For instance with Name="foo", Suffix = "v" and TypeRange = "il",
+// the builtin generated will be __builtin_rvv_foo_i32m1 and
+// __builtin_rvv_foo_i64m1 (under LMUL=1). If Suffix contains more than one
+// type transformer (say "vv") each of the types is separated with an
+// underscore as in "__builtin_rvv_foo_i32m1_i32m1".
+//
+// The C/C++ prototype of the builtin is defined by the Prototype attribute.
+// Prototype is a non-empty sequence of type transformers, the first of which
+// is the return type of the builtin and the rest are the parameters of the
+// builtin, in order. For instance if Prototype is "wvv" and TypeRange is "si"
+// a first builtin will have type
+// __rvv_int32m2_t (__rvv_int16m1_t, __rvv_int16m1_t) and the second builtin
+// will have type __rvv_int64m2_t (__rvv_int32m1_t, __rvv_int32m1_t) (again
+// under LMUL=1).
+//
+// There are a number of attributes that are used to constraint the number and
+// shape of the builtins generated. Refer to the comments below for them.
+
+class PolicyScheme<int val>{
+  int Value = val;
+}
+def NonePolicy : PolicyScheme<0>;
+def HasPassthruOperand : PolicyScheme<1>;
+def HasPolicyOperand : PolicyScheme<2>;
+
+class RVVBuiltin<string suffix, string prototype, string type_range,
+                 string overloaded_suffix = ""> {
+  // Base name that will be prepended in __builtin_rvv_ and appended the
+  // computed Suffix.
+  string Name = NAME;
+
+  // If not empty, each instantiated builtin will have this appended after an
+  // underscore (_). It is instantiated like Prototype.
+  string Suffix = suffix;
+
+  // If empty, default OverloadedName is sub string of `Name` which end of first
+  // '_'. For example, the default overloaded name  is `vadd` for Name `vadd_vv`.
+  // It's used for describe some special naming cases.
+  string OverloadedName = "";
+
+  // If not empty, each OverloadedName will have this appended after an
+  // underscore (_). It is instantiated like Prototype.
+  string OverloadedSuffix = overloaded_suffix;
+
+  // The different variants of the builtin, parameterised with a type.
+  string TypeRange = type_range;
+
+  // We use each type described in TypeRange and LMUL with prototype to
+  // instantiate a specific element of the set of builtins being defined.
+  // Prototype attribute defines the C/C++ prototype of the builtin. It is a
+  // non-empty sequence of type transformers, the first of which is the return
+  // type of the builtin and the rest are the parameters of the builtin, in
+  // order. For instance if Prototype is "wvv", TypeRange is "si" and LMUL=1, a
+  // first builtin will have type
+  // __rvv_int32m2_t (__rvv_int16m1_t, __rvv_int16m1_t), and the second builtin
+  // will have type __rvv_int64m2_t (__rvv_int32m1_t, __rvv_int32m1_t).
+  string Prototype = prototype;
+
+  // This builtin has a masked form.
+  bit HasMasked = true;
+
+  // If HasMasked, this flag states that this builtin has a maskedoff operand. It
+  // is always the first operand in builtin and IR intrinsic.
+  bit HasMaskedOffOperand = true;
+
+  // This builtin has a granted vector length parameter.
+  bit HasVL = true;
+
+  // The policy scheme for masked intrinsic IR.
+  // It could be NonePolicy or HasPolicyOperand.
+  // HasPolicyOperand: Has a policy operand. 0 is tail and mask undisturbed, 1 is
+  // tail agnostic, 2 is mask undisturbed, and 3 is tail and mask agnostic. The
+  // policy operand is located at the last position.
+  PolicyScheme MaskedPolicyScheme = HasPolicyOperand;
+
+  // The policy scheme for unmasked intrinsic IR.
+  // It could be NonePolicy, HasPassthruOperand or HasPolicyOperand.
+  // HasPassthruOperand: Has a passthru operand to decide tail policy. If it is
+  // poison, tail policy is tail agnostic, otherwise policy is tail undisturbed.
+  // HasPolicyOperand: Has a policy operand. 1 is tail agnostic and 0 is tail
+  // undisturbed.
+  PolicyScheme UnMaskedPolicyScheme = NonePolicy;
+
+  // This builtin support tail agnostic and undisturbed policy.
+  bit HasTailPolicy = true;
+  // This builtin support mask agnostic and undisturbed policy.
+  bit HasMaskPolicy = true;
+
+  // This builtin prototype with TA or TAMA policy could not support overloading
+  // API. Other policy intrinsic functions would support overloading API with
+  // suffix `_tu`, `tumu`, `tuma`, `tamu` and `tama`.
+  bit SupportOverloading = true;
+
+  // This builtin is valid for the given Log2LMULs.
+  list<int> Log2LMUL = [0, 1, 2, 3, -1, -2, -3];
+
+  // Manual code in clang codegen riscv_vector_builtin_cg.inc
+  code ManualCodegen = [{}];
+
+  // When emit the automatic clang codegen, it describes what types we have to use
+  // to obtain the specific LLVM intrinsic. -1 means the return type, otherwise,
+  // k >= 0 meaning the k-th operand (counting from zero) of the codegen'd
+  // parameter of the unmasked version. k can't be the mask operand's position.
+  list<int> IntrinsicTypes = [];
+
+  // If these names are not empty, this is the ID of the LLVM intrinsic
+  // we want to lower to.
+  string IRName = NAME;
+
+  // If HasMasked, this is the ID of the LLVM intrinsic we want to lower to.
+  string MaskedIRName = NAME #"_mask";
+
+  // Use clang_builtin_alias to save the number of builtins.
+  bit HasBuiltinAlias = true;
+
+  // Features required to enable for this builtin.
+  list<string> RequiredFeatures = [];
+
+  // Number of fields for Load/Store Segment instructions.
+  int NF = 1;
+}
+
+// This is the code emitted in the header.
+class RVVHeader {
+  code HeaderCode;
+}
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/RISCVIntrinsicManager.h b/clang/include/clang/Sema/RISCVIntrinsicManager.h
--- a/clang/include/clang/Sema/RISCVIntrinsicManager.h
+++ b/clang/include/clang/Sema/RISCVIntrinsicManager.h
@@ -14,6 +14,8 @@
 #ifndef LLVM_CLANG_SEMA_RISCVINTRINSICMANAGER_H
 #define LLVM_CLANG_SEMA_RISCVINTRINSICMANAGER_H
 
+#include <cstdint>
+
 namespace clang {
 class LookupResult;
 class IdentifierInfo;
@@ -22,6 +24,8 @@
 namespace sema {
 class RISCVIntrinsicManager {
 public:
+  enum class IntrinsicKind : uint8_t { RVV, SIFIVE_VECTOR };
+
   virtual ~RISCVIntrinsicManager() = default;
 
   // Create RISC-V intrinsic and insert into symbol table and return true if
diff -ruN --strip-trailing-cr a/clang/include/clang/Sema/Sema.h b/clang/include/clang/Sema/Sema.h
--- a/clang/include/clang/Sema/Sema.h
+++ b/clang/include/clang/Sema/Sema.h
@@ -1621,6 +1621,9 @@
   /// Indicate RISC-V vector builtin functions enabled or not.
   bool DeclareRISCVVBuiltins = false;
 
+  /// Indicate RISC-V Sifive vector builtin functions enabled or not.
+  bool DeclareRISCVVectorBuiltins = false;
+
 private:
   std::unique_ptr<sema::RISCVIntrinsicManager> RVIntrinsicManager;
 
diff -ruN --strip-trailing-cr a/clang/lib/CodeGen/CGBuiltin.cpp b/clang/lib/CodeGen/CGBuiltin.cpp
--- a/clang/lib/CodeGen/CGBuiltin.cpp
+++ b/clang/lib/CodeGen/CGBuiltin.cpp
@@ -20019,6 +20019,8 @@
 
   // Vector builtins are handled from here.
 #include "clang/Basic/riscv_vector_builtin_cg.inc"
+  // SiFive Vector builtins are handled from here.
+#include "clang/Basic/riscv_sifive_vector_builtin_cg.inc"
   }
 
   assert(ID != Intrinsic::not_intrinsic);
diff -ruN --strip-trailing-cr a/clang/lib/Headers/CMakeLists.txt b/clang/lib/Headers/CMakeLists.txt
--- a/clang/lib/Headers/CMakeLists.txt
+++ b/clang/lib/Headers/CMakeLists.txt
@@ -102,6 +102,10 @@
   riscv_ntlh.h
   )
 
+set(sifive_files
+  sifive_vector.h
+  )
+
 set(systemz_files
   s390intrin.h
   vecintrin.h
@@ -249,6 +253,7 @@
   ${ppc_files}
   ${ppc_htm_files}
   ${riscv_files}
+  ${sifive_files}
   ${systemz_files}
   ${ve_files}
   ${x86_files}
diff -ruN --strip-trailing-cr a/clang/lib/Headers/sifive_vector.h b/clang/lib/Headers/sifive_vector.h
--- a/clang/lib/Headers/sifive_vector.h
+++ b/clang/lib/Headers/sifive_vector.h
@@ -0,0 +1,16 @@
+//===----- sifive_vector.h - SiFive Vector definitions --------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _SIFIVE_VECTOR_H_
+#define _SIFIVE_VECTOR_H_
+
+#include "riscv_vector.h"
+
+#pragma clang riscv intrinsic sifive_vector
+
+#endif //_SIFIVE_VECTOR_H_
diff -ruN --strip-trailing-cr a/clang/lib/Parse/ParsePragma.cpp b/clang/lib/Parse/ParsePragma.cpp
--- a/clang/lib/Parse/ParsePragma.cpp
+++ b/clang/lib/Parse/ParsePragma.cpp
@@ -4024,6 +4024,7 @@
 }
 
 // Handle '#pragma clang riscv intrinsic vector'.
+//        '#pragma clang riscv intrinsic sifive_vector'.
 void PragmaRISCVHandler::HandlePragma(Preprocessor &PP,
                                       PragmaIntroducer Introducer,
                                       Token &FirstToken) {
@@ -4039,9 +4040,11 @@
 
   PP.Lex(Tok);
   II = Tok.getIdentifierInfo();
-  if (!II || !II->isStr("vector")) {
+  StringRef IntrinsicClass = II->getName();
+  if (!II || !(II->isStr("vector") || II->isStr("sifive_vector"))) {
     PP.Diag(Tok.getLocation(), diag::warn_pragma_invalid_argument)
-        << PP.getSpelling(Tok) << "riscv" << /*Expected=*/true << "'vector'";
+        << PP.getSpelling(Tok) << "riscv" << /*Expected=*/true
+        << "'vector' or 'sifive_vector'";
     return;
   }
 
@@ -4052,5 +4055,8 @@
     return;
   }
 
-  Actions.DeclareRISCVVBuiltins = true;
+  if (IntrinsicClass == "vector")
+    Actions.DeclareRISCVVBuiltins = true;
+  else if (IntrinsicClass == "sifive_vector")
+    Actions.DeclareRISCVVectorBuiltins = true;
 }
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaLookup.cpp b/clang/lib/Sema/SemaLookup.cpp
--- a/clang/lib/Sema/SemaLookup.cpp
+++ b/clang/lib/Sema/SemaLookup.cpp
@@ -933,7 +933,7 @@
         }
       }
 
-      if (DeclareRISCVVBuiltins) {
+      if (DeclareRISCVVBuiltins || DeclareRISCVVectorBuiltins) {
         if (!RVIntrinsicManager)
           RVIntrinsicManager = CreateRISCVIntrinsicManager(*this);
 
diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaRISCVVectorLookup.cpp b/clang/lib/Sema/SemaRISCVVectorLookup.cpp
--- a/clang/lib/Sema/SemaRISCVVectorLookup.cpp
+++ b/clang/lib/Sema/SemaRISCVVectorLookup.cpp
@@ -28,6 +28,8 @@
 using namespace clang;
 using namespace clang::RISCV;
 
+using IntrinsicKind = sema::RISCVIntrinsicManager::IntrinsicKind;
+
 namespace {
 
 // Function definition of a RVV intrinsic.
@@ -58,16 +60,35 @@
 #undef DECL_SIGNATURE_TABLE
 };
 
+static const PrototypeDescriptor RVSiFiveVectorSignatureTable[] = {
+#define DECL_SIGNATURE_TABLE
+#include "clang/Basic/riscv_sifive_vector_builtin_sema.inc"
+#undef DECL_SIGNATURE_TABLE
+};
+
 static const RVVIntrinsicRecord RVVIntrinsicRecords[] = {
 #define DECL_INTRINSIC_RECORDS
 #include "clang/Basic/riscv_vector_builtin_sema.inc"
 #undef DECL_INTRINSIC_RECORDS
 };
 
+static const RVVIntrinsicRecord RVSiFiveVectorIntrinsicRecords[] = {
+#define DECL_INTRINSIC_RECORDS
+#include "clang/Basic/riscv_sifive_vector_builtin_sema.inc"
+#undef DECL_INTRINSIC_RECORDS
+};
+
 // Get subsequence of signature table.
-static ArrayRef<PrototypeDescriptor> ProtoSeq2ArrayRef(uint16_t Index,
-                                                       uint8_t Length) {
-  return ArrayRef(&RVVSignatureTable[Index], Length);
+static ArrayRef<PrototypeDescriptor>
+ProtoSeq2ArrayRef(IntrinsicKind K, uint16_t Index, uint8_t Length) {
+  switch (K) {
+  default:
+    llvm_unreachable("Unsupported intrinsic kind.");
+  case IntrinsicKind::RVV:
+    return ArrayRef(&RVVSignatureTable[Index], Length);
+  case IntrinsicKind::SIFIVE_VECTOR:
+    return ArrayRef(&RVSiFiveVectorSignatureTable[Index], Length);
+  }
 }
 
 static QualType RVVType2Qual(ASTContext &Context, const RVVType *Type) {
@@ -172,123 +193,132 @@
   bool HasRV64 = TI.hasFeature("64bit");
   bool HasFullMultiply = TI.hasFeature("v");
 
-  // Construction of RVVIntrinsicRecords need to sync with createRVVIntrinsics
-  // in RISCVVEmitter.cpp.
-  for (auto &Record : RVVIntrinsicRecords) {
-    // Create Intrinsics for each type and LMUL.
-    BasicType BaseType = BasicType::Unknown;
-    ArrayRef<PrototypeDescriptor> BasicProtoSeq =
-        ProtoSeq2ArrayRef(Record.PrototypeIndex, Record.PrototypeLength);
-    ArrayRef<PrototypeDescriptor> SuffixProto =
-        ProtoSeq2ArrayRef(Record.SuffixIndex, Record.SuffixLength);
-    ArrayRef<PrototypeDescriptor> OverloadedSuffixProto = ProtoSeq2ArrayRef(
-        Record.OverloadedSuffixIndex, Record.OverloadedSuffixSize);
-
-    PolicyScheme UnMaskedPolicyScheme =
-        static_cast<PolicyScheme>(Record.UnMaskedPolicyScheme);
-    PolicyScheme MaskedPolicyScheme =
-        static_cast<PolicyScheme>(Record.MaskedPolicyScheme);
-
-    const Policy DefaultPolicy;
-
-    llvm::SmallVector<PrototypeDescriptor> ProtoSeq =
-        RVVIntrinsic::computeBuiltinTypes(BasicProtoSeq, /*IsMasked=*/false,
-                                          /*HasMaskedOffOperand=*/false,
-                                          Record.HasVL, Record.NF,
-                                          UnMaskedPolicyScheme, DefaultPolicy);
-
-    llvm::SmallVector<PrototypeDescriptor> ProtoMaskSeq =
-        RVVIntrinsic::computeBuiltinTypes(
-            BasicProtoSeq, /*IsMasked=*/true, Record.HasMaskedOffOperand,
-            Record.HasVL, Record.NF, MaskedPolicyScheme, DefaultPolicy);
-
-    bool UnMaskedHasPolicy = UnMaskedPolicyScheme != PolicyScheme::SchemeNone;
-    bool MaskedHasPolicy = MaskedPolicyScheme != PolicyScheme::SchemeNone;
-    SmallVector<Policy> SupportedUnMaskedPolicies =
-        RVVIntrinsic::getSupportedUnMaskedPolicies();
-    SmallVector<Policy> SupportedMaskedPolicies =
-        RVVIntrinsic::getSupportedMaskedPolicies(Record.HasTailPolicy,
-                                                 Record.HasMaskPolicy);
-
-    for (unsigned int TypeRangeMaskShift = 0;
-         TypeRangeMaskShift <= static_cast<unsigned int>(BasicType::MaxOffset);
-         ++TypeRangeMaskShift) {
-      unsigned int BaseTypeI = 1 << TypeRangeMaskShift;
-      BaseType = static_cast<BasicType>(BaseTypeI);
-
-      if ((BaseTypeI & Record.TypeRangeMask) != BaseTypeI)
-        continue;
-
-      // Check requirement.
-      if (((Record.RequiredExtensions & RVV_REQ_RV64) == RVV_REQ_RV64) &&
-          !HasRV64)
-        continue;
-
-      if ((BaseType == BasicType::Int64) &&
-          ((Record.RequiredExtensions & RVV_REQ_FullMultiply) ==
-           RVV_REQ_FullMultiply) &&
-          !HasFullMultiply)
-        continue;
-
-      // Expanded with different LMUL.
-      for (int Log2LMUL = -3; Log2LMUL <= 3; Log2LMUL++) {
-        if (!(Record.Log2LMULMask & (1 << (Log2LMUL + 3))))
+  auto ConstructRVVIntrinsics = [&](ArrayRef<RVVIntrinsicRecord> Recs,
+                                    IntrinsicKind K) {
+    // Construction of RVVIntrinsicRecords need to sync with createRVVIntrinsics
+    // in RISCVVEmitter.cpp.
+    for (auto &Record : Recs) {
+      // Create Intrinsics for each type and LMUL.
+      BasicType BaseType = BasicType::Unknown;
+      ArrayRef<PrototypeDescriptor> BasicProtoSeq =
+          ProtoSeq2ArrayRef(K, Record.PrototypeIndex, Record.PrototypeLength);
+      ArrayRef<PrototypeDescriptor> SuffixProto =
+          ProtoSeq2ArrayRef(K, Record.SuffixIndex, Record.SuffixLength);
+      ArrayRef<PrototypeDescriptor> OverloadedSuffixProto = ProtoSeq2ArrayRef(
+          K, Record.OverloadedSuffixIndex, Record.OverloadedSuffixSize);
+
+      PolicyScheme UnMaskedPolicyScheme =
+          static_cast<PolicyScheme>(Record.UnMaskedPolicyScheme);
+      PolicyScheme MaskedPolicyScheme =
+          static_cast<PolicyScheme>(Record.MaskedPolicyScheme);
+
+      const Policy DefaultPolicy;
+
+      llvm::SmallVector<PrototypeDescriptor> ProtoSeq =
+          RVVIntrinsic::computeBuiltinTypes(BasicProtoSeq, /*IsMasked=*/false,
+                                            /*HasMaskedOffOperand=*/false,
+                                            Record.HasVL, Record.NF,
+                                            UnMaskedPolicyScheme, DefaultPolicy);
+
+      llvm::SmallVector<PrototypeDescriptor> ProtoMaskSeq =
+          RVVIntrinsic::computeBuiltinTypes(
+              BasicProtoSeq, /*IsMasked=*/true, Record.HasMaskedOffOperand,
+              Record.HasVL, Record.NF, MaskedPolicyScheme, DefaultPolicy);
+
+      bool UnMaskedHasPolicy = UnMaskedPolicyScheme != PolicyScheme::SchemeNone;
+      bool MaskedHasPolicy = MaskedPolicyScheme != PolicyScheme::SchemeNone;
+      SmallVector<Policy> SupportedUnMaskedPolicies =
+          RVVIntrinsic::getSupportedUnMaskedPolicies();
+      SmallVector<Policy> SupportedMaskedPolicies =
+          RVVIntrinsic::getSupportedMaskedPolicies(Record.HasTailPolicy,
+                                                   Record.HasMaskPolicy);
+
+      for (unsigned int TypeRangeMaskShift = 0;
+           TypeRangeMaskShift <= static_cast<unsigned int>(BasicType::MaxOffset);
+           ++TypeRangeMaskShift) {
+        unsigned int BaseTypeI = 1 << TypeRangeMaskShift;
+        BaseType = static_cast<BasicType>(BaseTypeI);
+
+        if ((BaseTypeI & Record.TypeRangeMask) != BaseTypeI)
           continue;
 
-        std::optional<RVVTypes> Types =
-            TypeCache.computeTypes(BaseType, Log2LMUL, Record.NF, ProtoSeq);
+        // Check requirement.
+        if (((Record.RequiredExtensions & RVV_REQ_RV64) == RVV_REQ_RV64) &&
+            !HasRV64)
+          continue;
 
-        // Ignored to create new intrinsic if there are any illegal types.
-        if (!Types.has_value())
+        if ((BaseType == BasicType::Int64) &&
+            ((Record.RequiredExtensions & RVV_REQ_FullMultiply) ==
+             RVV_REQ_FullMultiply) &&
+            !HasFullMultiply)
           continue;
 
-        std::string SuffixStr = RVVIntrinsic::getSuffixStr(
-            TypeCache, BaseType, Log2LMUL, SuffixProto);
-        std::string OverloadedSuffixStr = RVVIntrinsic::getSuffixStr(
-            TypeCache, BaseType, Log2LMUL, OverloadedSuffixProto);
-
-        // Create non-masked intrinsic.
-        InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr, false, *Types,
-                         UnMaskedHasPolicy, DefaultPolicy);
-
-        // Create non-masked policy intrinsic.
-        if (Record.UnMaskedPolicyScheme != PolicyScheme::SchemeNone) {
-          for (const auto &P : SupportedUnMaskedPolicies) {
+        // Expanded with different LMUL.
+        for (int Log2LMUL = -3; Log2LMUL <= 3; Log2LMUL++) {
+          if (!(Record.Log2LMULMask & (1 << (Log2LMUL + 3))))
+            continue;
+
+          std::optional<RVVTypes> Types =
+              TypeCache.computeTypes(BaseType, Log2LMUL, Record.NF, ProtoSeq);
+
+          // Ignored to create new intrinsic if there are any illegal types.
+          if (!Types.has_value())
+            continue;
+
+          std::string SuffixStr = RVVIntrinsic::getSuffixStr(
+              TypeCache, BaseType, Log2LMUL, SuffixProto);
+          std::string OverloadedSuffixStr = RVVIntrinsic::getSuffixStr(
+              TypeCache, BaseType, Log2LMUL, OverloadedSuffixProto);
+
+          // Create non-masked intrinsic.
+          InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr, false, *Types,
+                           UnMaskedHasPolicy, DefaultPolicy);
+
+          // Create non-masked policy intrinsic.
+          if (Record.UnMaskedPolicyScheme != PolicyScheme::SchemeNone) {
+            for (auto P : SupportedUnMaskedPolicies) {
+              llvm::SmallVector<PrototypeDescriptor> PolicyPrototype =
+                  RVVIntrinsic::computeBuiltinTypes(
+                      BasicProtoSeq, /*IsMasked=*/false,
+                      /*HasMaskedOffOperand=*/false, Record.HasVL, Record.NF,
+                      UnMaskedPolicyScheme, P);
+              std::optional<RVVTypes> PolicyTypes = TypeCache.computeTypes(
+                  BaseType, Log2LMUL, Record.NF, PolicyPrototype);
+              InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr,
+                               /*IsMask=*/false, *PolicyTypes, UnMaskedHasPolicy,
+                               P);
+            }
+          }
+          if (!Record.HasMasked)
+            continue;
+          // Create masked intrinsic.
+          std::optional<RVVTypes> MaskTypes =
+              TypeCache.computeTypes(BaseType, Log2LMUL, Record.NF, ProtoMaskSeq);
+          InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr, true,
+                           *MaskTypes, MaskedHasPolicy, DefaultPolicy);
+          if (Record.MaskedPolicyScheme == PolicyScheme::SchemeNone)
+            continue;
+          // Create masked policy intrinsic.
+          for (auto P : SupportedMaskedPolicies) {
             llvm::SmallVector<PrototypeDescriptor> PolicyPrototype =
                 RVVIntrinsic::computeBuiltinTypes(
-                    BasicProtoSeq, /*IsMasked=*/false,
-                    /*HasMaskedOffOperand=*/false, Record.HasVL, Record.NF,
-                    UnMaskedPolicyScheme, P);
+                    BasicProtoSeq, /*IsMasked=*/true, Record.HasMaskedOffOperand,
+                    Record.HasVL, Record.NF, MaskedPolicyScheme, P);
             std::optional<RVVTypes> PolicyTypes = TypeCache.computeTypes(
                 BaseType, Log2LMUL, Record.NF, PolicyPrototype);
             InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr,
-                             /*IsMask=*/false, *PolicyTypes, UnMaskedHasPolicy,
-                             P);
+                             /*IsMask=*/true, *PolicyTypes, MaskedHasPolicy, P);
           }
-        }
-        if (!Record.HasMasked)
-          continue;
-        // Create masked intrinsic.
-        std::optional<RVVTypes> MaskTypes =
-            TypeCache.computeTypes(BaseType, Log2LMUL, Record.NF, ProtoMaskSeq);
-        InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr, true,
-                         *MaskTypes, MaskedHasPolicy, DefaultPolicy);
-        if (Record.MaskedPolicyScheme == PolicyScheme::SchemeNone)
-          continue;
-        // Create masked policy intrinsic.
-        for (auto P : SupportedMaskedPolicies) {
-          llvm::SmallVector<PrototypeDescriptor> PolicyPrototype =
-              RVVIntrinsic::computeBuiltinTypes(
-                  BasicProtoSeq, /*IsMasked=*/true, Record.HasMaskedOffOperand,
-                  Record.HasVL, Record.NF, MaskedPolicyScheme, P);
-          std::optional<RVVTypes> PolicyTypes = TypeCache.computeTypes(
-              BaseType, Log2LMUL, Record.NF, PolicyPrototype);
-          InitRVVIntrinsic(Record, SuffixStr, OverloadedSuffixStr,
-                           /*IsMask=*/true, *PolicyTypes, MaskedHasPolicy, P);
-        }
-      } // End for different LMUL
-    } // End for different TypeRange
-  }
+        } // End for different LMUL
+      } // End for different TypeRange
+    }
+  };
+  if (S.DeclareRISCVVBuiltins)
+    ConstructRVVIntrinsics(RVVIntrinsicRecords,
+                           IntrinsicKind::RVV);
+  if (S.DeclareRISCVVectorBuiltins)
+    ConstructRVVIntrinsics(RVSiFiveVectorIntrinsicRecords,
+                           IntrinsicKind::SIFIVE_VECTOR);
 }
 
 // Compute name and signatures for intrinsic with practical types.
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x-rv64.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x-rv64.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x-rv64.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x-rv64.c
@@ -1,7 +1,7 @@
 // NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p24_20 (0b11111)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-x.c
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -triple riscv32 -target-feature +v -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV32 %s
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p24_20 (0b11111)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv-rv64.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv-rv64.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv-rv64.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv-rv64.c
@@ -2,7 +2,7 @@
 // REQUIRES: riscv-registered-target
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p11_7  (0b11111)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xv.c
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -triple riscv32 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV32 %s
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p26    (0b1)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv-rv64.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv-rv64.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv-rv64.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv-rv64.c
@@ -2,7 +2,7 @@
 // REQUIRES: riscv-registered-target
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvv.c
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -triple riscv32 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV32 %s
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p26    (0b1)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvw.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvw.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvw.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-autogenerated/non-policy/non-overloaded/xsfvcp-xvw.c
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -triple riscv32 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV32 %s
 // RUN: %clang_cc1 -triple riscv64 -target-feature +v -target-feature +zfh -target-feature +xsfvcp -disable-O0-optnone -emit-llvm %s -o - | opt -S -passes=mem2reg | FileCheck --check-prefix=CHECK-RV64 %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p26    (0b1)
diff -ruN --strip-trailing-cr a/clang/test/CodeGen/RISCV/rvv-intrinsics-handcrafted/xsfvcp-index-out-of-range.c b/clang/test/CodeGen/RISCV/rvv-intrinsics-handcrafted/xsfvcp-index-out-of-range.c
--- a/clang/test/CodeGen/RISCV/rvv-intrinsics-handcrafted/xsfvcp-index-out-of-range.c
+++ b/clang/test/CodeGen/RISCV/rvv-intrinsics-handcrafted/xsfvcp-index-out-of-range.c
@@ -5,7 +5,7 @@
 // RUN:   -target-feature +xsfvcp \
 // RUN:   -fsyntax-only -verify %s
 
-#include <riscv_vector.h>
+#include <sifive_vector.h>
 
 #define p27_26 (0b11)
 #define p26    (0b1)
diff -ruN --strip-trailing-cr a/clang/test/Sema/riscv-bad-intrinsic-pragma.c b/clang/test/Sema/riscv-bad-intrinsic-pragma.c
--- a/clang/test/Sema/riscv-bad-intrinsic-pragma.c
+++ b/clang/test/Sema/riscv-bad-intrinsic-pragma.c
@@ -2,7 +2,7 @@
 // RUN:            2>&1 | FileCheck %s
 
 #pragma clang riscv intrinsic vvvv
-// CHECK:      warning: unexpected argument 'vvvv' to '#pragma riscv'; expected 'vector' [-Wignored-pragmas]
+// CHECK:      warning: unexpected argument 'vvvv' to '#pragma riscv'; expected 'vector' or 'sifive_vector' [-Wignored-pragmas]
 
 #pragma clang riscv what + 3241
 // CHECK:      warning: unexpected argument 'what' to '#pragma riscv'; expected 'intrinsic' [-Wignored-pragmas]
diff -ruN --strip-trailing-cr a/clang/utils/TableGen/TableGen.cpp b/clang/utils/TableGen/TableGen.cpp
--- a/clang/utils/TableGen/TableGen.cpp
+++ b/clang/utils/TableGen/TableGen.cpp
@@ -91,6 +91,9 @@
   GenRISCVVectorBuiltins,
   GenRISCVVectorBuiltinCG,
   GenRISCVVectorBuiltinSema,
+  GenRISCVSiFiveVectorBuiltins,
+  GenRISCVSiFiveVectorBuiltinCG,
+  GenRISCVSiFiveVectorBuiltinSema,
   GenAttrDocs,
   GenDiagDocs,
   GenOptDocs,
@@ -251,6 +254,12 @@
                    "Generate riscv_vector_builtin_cg.inc for clang"),
         clEnumValN(GenRISCVVectorBuiltinSema, "gen-riscv-vector-builtin-sema",
                    "Generate riscv_vector_builtin_sema.inc for clang"),
+        clEnumValN(GenRISCVSiFiveVectorBuiltins, "gen-riscv-sifive-vector-builtins",
+                   "Generate riscv_sifive_vector_builtins.inc for clang"),
+        clEnumValN(GenRISCVSiFiveVectorBuiltinCG, "gen-riscv-sifive-vector-builtin-codegen",
+                   "Generate riscv_sifive_vector_builtin_cg.inc for clang"),
+        clEnumValN(GenRISCVSiFiveVectorBuiltinSema, "gen-riscv-sifive-vector-builtin-sema",
+                   "Generate riscv_sifive_vector_builtin_sema.inc for clang"),
         clEnumValN(GenAttrDocs, "gen-attr-docs",
                    "Generate attribute documentation"),
         clEnumValN(GenDiagDocs, "gen-diag-docs",
@@ -472,6 +481,15 @@
   case GenRISCVVectorBuiltinSema:
     EmitRVVBuiltinSema(Records, OS);
     break;
+  case GenRISCVSiFiveVectorBuiltins:
+    EmitRVVBuiltins(Records, OS);
+    break;
+  case GenRISCVSiFiveVectorBuiltinCG:
+    EmitRVVBuiltinCG(Records, OS);
+    break;
+  case GenRISCVSiFiveVectorBuiltinSema:
+    EmitRVVBuiltinSema(Records, OS);
+    break;
   case GenAttrDocs:
     EmitClangAttrDocs(Records, OS);
     break;
diff -ruN --strip-trailing-cr a/lldb/include/lldb/API/SBFile.h b/lldb/include/lldb/API/SBFile.h
--- a/lldb/include/lldb/API/SBFile.h
+++ b/lldb/include/lldb/API/SBFile.h
@@ -11,6 +11,8 @@
 
 #include "lldb/API/SBDefines.h"
 
+#include <cstdio>
+
 namespace lldb {
 
 class LLDB_API SBFile {
diff -ruN --strip-trailing-cr a/lldb/source/Expression/DWARFExpression.cpp b/lldb/source/Expression/DWARFExpression.cpp
--- a/lldb/source/Expression/DWARFExpression.cpp
+++ b/lldb/source/Expression/DWARFExpression.cpp
@@ -1436,12 +1436,8 @@
           return false;
         } else {
           stack.pop_back();
-          Scalar divisor, dividend;
-          divisor = tmp.ResolveValue(exe_ctx);
-          dividend = stack.back().ResolveValue(exe_ctx);
-          divisor.MakeSigned();
-          dividend.MakeSigned();
-          stack.back() = dividend / divisor;
+          stack.back() =
+              stack.back().ResolveValue(exe_ctx) / tmp.ResolveValue(exe_ctx);
           if (!stack.back().ResolveValue(exe_ctx).IsValid()) {
             if (error_ptr)
               error_ptr->SetErrorString("Divide failed.");
diff -ruN --strip-trailing-cr a/lldb/test/Shell/SymbolFile/DWARF/x86/DW_OP_div-with-signed.s b/lldb/test/Shell/SymbolFile/DWARF/x86/DW_OP_div-with-signed.s
--- a/lldb/test/Shell/SymbolFile/DWARF/x86/DW_OP_div-with-signed.s
+++ b/lldb/test/Shell/SymbolFile/DWARF/x86/DW_OP_div-with-signed.s
@@ -1,468 +0,0 @@
-  # Test handling of values represented via DW_OP_div
-
-  # RUN: %clang --target=x86_64-pc-linux -o %t %s
-  # RUN: %lldb %t -o "b f" -o "r" -o "c" -o "c" -o "expression -T -- i" \
-  # RUN: -o "exit" | FileCheck %s
-
-  # Failing case was:
-  # (uint32_t) $0 = 0
-  # CHECK: (uint32_t) $0 = 2
-	
-  # This case is generated from the following code:
-  # #include "stdint.h"
-  # static volatile uint64_t g = 0;
-  #  static const int32_t f()
-  #  {
-  #    uint32_t i;
-  #        for (i = 0; (i != 10); i++)
-  #              ++g;
-  #        return 0;
-  #                  
-  #  }
-  #
-  #  int main()
-  #  {
-  #    f();
-  #    return 0;
-  #        
-  #  }
-
-  .text
-	.file	"signed_dw_op_div.c"
-	.file	1 "/usr/local/include/bits" "types.h" md5 0x96c0983c9cdaf387938a8268d00aa594
-	.file	2 "/usr/local/include/bits" "stdint-uintn.h" md5 0xbedfab747425222bb150968c14e40abd
-	.globl	main                            # -- Begin function main
-	.p2align	4, 0x90
-	.type	main,@function
-main:                                   # @main
-.Lfunc_begin0:
-	.loc	0 13 0                          # signed_dw_op_div.c:13:0
-	.cfi_startproc
-# %bb.0:
-	movl	$3, %eax
-	#DEBUG_VALUE: f:i <- 0
-	.p2align	4, 0x90
-.LBB0_1:                                # =>This Inner Loop Header: Depth=1
-.Ltmp0:
-	#DEBUG_VALUE: f:i <- [DW_OP_consts 3, DW_OP_minus, DW_OP_consts 18446744073709551615, DW_OP_div, DW_OP_stack_value] $eax
-	.loc	0 8 7 prologue_end              # signed_dw_op_div.c:8:7
-	incq	g(%rip)
-.Ltmp1:
-	#DEBUG_VALUE: f:i <- [DW_OP_consts 3, DW_OP_minus, DW_OP_consts 18446744073709551615, DW_OP_div, DW_OP_consts 1, DW_OP_plus, DW_OP_stack_value] $eax
-	.loc	0 7 20                          # signed_dw_op_div.c:7:20
-	decl	%eax
-.Ltmp2:
-	.loc	0 7 5 is_stmt 0                 # signed_dw_op_div.c:7:5
-	jne	.LBB0_1
-.Ltmp3:
-# %bb.2:
-	.loc	0 15 5 is_stmt 1                # signed_dw_op_div.c:15:5
-	xorl	%eax, %eax
-	retq
-.Ltmp4:
-.Lfunc_end0:
-	.size	main, .Lfunc_end0-main
-	.cfi_endproc
-	.file	3 "/usr/local/include/bits" "stdint-intn.h" md5 0x90039fb90b44dcbf118222513050fe57
-                                        # -- End function
-	.type	g,@object                       # @g
-	.local	g
-	.comm	g,8,8
-	.section	.debug_loclists,"",@progbits
-	.long	.Ldebug_list_header_end0-.Ldebug_list_header_start0 # Length
-.Ldebug_list_header_start0:
-	.short	5                               # Version
-	.byte	8                               # Address size
-	.byte	0                               # Segment selector size
-	.long	1                               # Offset entry count
-.Lloclists_table_base0:
-	.long	.Ldebug_loc0-.Lloclists_table_base0
-.Ldebug_loc0:
-	.byte	4                               # DW_LLE_offset_pair
-	.uleb128 .Ltmp0-.Lfunc_begin0           #   starting offset
-	.uleb128 .Ltmp1-.Lfunc_begin0           #   ending offset
-	.byte	16                              # Loc expr size
-	.byte	112                             # DW_OP_breg0
-	.byte	0                               # 0
-	.byte	16                              # DW_OP_constu
-	.byte	255                             # 4294967295
-	.byte	255                             # 
-	.byte	255                             # 
-	.byte	255                             # 
-	.byte	15                              # 
-	.byte	26                              # DW_OP_and
-	.byte	17                              # DW_OP_consts
-	.byte	3                               # 3
-	.byte	28                              # DW_OP_minus
-	.byte	17                              # DW_OP_consts
-	.byte	127                             # -1
-	.byte	27                              # DW_OP_div
-	.byte	159                             # DW_OP_stack_value
-	.byte	4                               # DW_LLE_offset_pair
-	.uleb128 .Ltmp1-.Lfunc_begin0           #   starting offset
-	.uleb128 .Ltmp2-.Lfunc_begin0           #   ending offset
-	.byte	19                              # Loc expr size
-	.byte	112                             # DW_OP_breg0
-	.byte	0                               # 0
-	.byte	16                              # DW_OP_constu
-	.byte	255                             # 4294967295
-	.byte	255                             # 
-	.byte	255                             # 
-	.byte	255                             # 
-	.byte	15                              # 
-	.byte	26                              # DW_OP_and
-	.byte	17                              # DW_OP_consts
-	.byte	3                               # 3
-	.byte	28                              # DW_OP_minus
-	.byte	17                              # DW_OP_consts
-	.byte	127                             # -1
-	.byte	27                              # DW_OP_div
-	.byte	17                              # DW_OP_consts
-	.byte	1                               # 1
-	.byte	34                              # DW_OP_plus
-	.byte	159                             # DW_OP_stack_value
-	.byte	0                               # DW_LLE_end_of_list
-.Ldebug_list_header_end0:
-	.section	.debug_abbrev,"",@progbits
-	.byte	1                               # Abbreviation Code
-	.byte	17                              # DW_TAG_compile_unit
-	.byte	1                               # DW_CHILDREN_yes
-	.byte	37                              # DW_AT_producer
-	.byte	37                              # DW_FORM_strx1
-	.byte	19                              # DW_AT_language
-	.byte	5                               # DW_FORM_data2
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	114                             # DW_AT_str_offsets_base
-	.byte	23                              # DW_FORM_sec_offset
-	.byte	16                              # DW_AT_stmt_list
-	.byte	23                              # DW_FORM_sec_offset
-	.byte	27                              # DW_AT_comp_dir
-	.byte	37                              # DW_FORM_strx1
-	.byte	17                              # DW_AT_low_pc
-	.byte	27                              # DW_FORM_addrx
-	.byte	18                              # DW_AT_high_pc
-	.byte	6                               # DW_FORM_data4
-	.byte	115                             # DW_AT_addr_base
-	.byte	23                              # DW_FORM_sec_offset
-	.ascii	"\214\001"                      # DW_AT_loclists_base
-	.byte	23                              # DW_FORM_sec_offset
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	2                               # Abbreviation Code
-	.byte	52                              # DW_TAG_variable
-	.byte	0                               # DW_CHILDREN_no
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	58                              # DW_AT_decl_file
-	.byte	11                              # DW_FORM_data1
-	.byte	59                              # DW_AT_decl_line
-	.byte	11                              # DW_FORM_data1
-	.byte	2                               # DW_AT_location
-	.byte	24                              # DW_FORM_exprloc
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	3                               # Abbreviation Code
-	.byte	53                              # DW_TAG_volatile_type
-	.byte	0                               # DW_CHILDREN_no
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	4                               # Abbreviation Code
-	.byte	22                              # DW_TAG_typedef
-	.byte	0                               # DW_CHILDREN_no
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	58                              # DW_AT_decl_file
-	.byte	11                              # DW_FORM_data1
-	.byte	59                              # DW_AT_decl_line
-	.byte	11                              # DW_FORM_data1
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	5                               # Abbreviation Code
-	.byte	36                              # DW_TAG_base_type
-	.byte	0                               # DW_CHILDREN_no
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	62                              # DW_AT_encoding
-	.byte	11                              # DW_FORM_data1
-	.byte	11                              # DW_AT_byte_size
-	.byte	11                              # DW_FORM_data1
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	6                               # Abbreviation Code
-	.byte	46                              # DW_TAG_subprogram
-	.byte	1                               # DW_CHILDREN_yes
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	58                              # DW_AT_decl_file
-	.byte	11                              # DW_FORM_data1
-	.byte	59                              # DW_AT_decl_line
-	.byte	11                              # DW_FORM_data1
-	.byte	54                              # DW_AT_calling_convention
-	.byte	11                              # DW_FORM_data1
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	32                              # DW_AT_inline
-	.byte	33                              # DW_FORM_implicit_const
-	.byte	1
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	7                               # Abbreviation Code
-	.byte	52                              # DW_TAG_variable
-	.byte	0                               # DW_CHILDREN_no
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	58                              # DW_AT_decl_file
-	.byte	11                              # DW_FORM_data1
-	.byte	59                              # DW_AT_decl_line
-	.byte	11                              # DW_FORM_data1
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	8                               # Abbreviation Code
-	.byte	38                              # DW_TAG_const_type
-	.byte	0                               # DW_CHILDREN_no
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	9                               # Abbreviation Code
-	.byte	46                              # DW_TAG_subprogram
-	.byte	1                               # DW_CHILDREN_yes
-	.byte	17                              # DW_AT_low_pc
-	.byte	27                              # DW_FORM_addrx
-	.byte	18                              # DW_AT_high_pc
-	.byte	6                               # DW_FORM_data4
-	.byte	64                              # DW_AT_frame_base
-	.byte	24                              # DW_FORM_exprloc
-	.byte	122                             # DW_AT_call_all_calls
-	.byte	25                              # DW_FORM_flag_present
-	.byte	3                               # DW_AT_name
-	.byte	37                              # DW_FORM_strx1
-	.byte	58                              # DW_AT_decl_file
-	.byte	11                              # DW_FORM_data1
-	.byte	59                              # DW_AT_decl_line
-	.byte	11                              # DW_FORM_data1
-	.byte	73                              # DW_AT_type
-	.byte	19                              # DW_FORM_ref4
-	.byte	63                              # DW_AT_external
-	.byte	25                              # DW_FORM_flag_present
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	10                              # Abbreviation Code
-	.byte	29                              # DW_TAG_inlined_subroutine
-	.byte	1                               # DW_CHILDREN_yes
-	.byte	49                              # DW_AT_abstract_origin
-	.byte	19                              # DW_FORM_ref4
-	.byte	17                              # DW_AT_low_pc
-	.byte	27                              # DW_FORM_addrx
-	.byte	18                              # DW_AT_high_pc
-	.byte	6                               # DW_FORM_data4
-	.byte	88                              # DW_AT_call_file
-	.byte	11                              # DW_FORM_data1
-	.byte	89                              # DW_AT_call_line
-	.byte	11                              # DW_FORM_data1
-	.byte	87                              # DW_AT_call_column
-	.byte	11                              # DW_FORM_data1
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	11                              # Abbreviation Code
-	.byte	52                              # DW_TAG_variable
-	.byte	0                               # DW_CHILDREN_no
-	.byte	2                               # DW_AT_location
-	.byte	34                              # DW_FORM_loclistx
-	.byte	49                              # DW_AT_abstract_origin
-	.byte	19                              # DW_FORM_ref4
-	.byte	0                               # EOM(1)
-	.byte	0                               # EOM(2)
-	.byte	0                               # EOM(3)
-	.section	.debug_info,"",@progbits
-.Lcu_begin0:
-	.long	.Ldebug_info_end0-.Ldebug_info_start0 # Length of Unit
-.Ldebug_info_start0:
-	.short	5                               # DWARF version number
-	.byte	1                               # DWARF Unit Type
-	.byte	8                               # Address Size (in bytes)
-	.long	.debug_abbrev                   # Offset Into Abbrev. Section
-	.byte	1                               # Abbrev [1] 0xc:0xa3 DW_TAG_compile_unit
-	.byte	0                               # DW_AT_producer
-	.short	12                              # DW_AT_language
-	.byte	1                               # DW_AT_name
-	.long	.Lstr_offsets_base0             # DW_AT_str_offsets_base
-	.long	.Lline_table_start0             # DW_AT_stmt_list
-	.byte	2                               # DW_AT_comp_dir
-	.byte	1                               # DW_AT_low_pc
-	.long	.Lfunc_end0-.Lfunc_begin0       # DW_AT_high_pc
-	.long	.Laddr_table_base0              # DW_AT_addr_base
-	.long	.Lloclists_table_base0          # DW_AT_loclists_base
-	.byte	2                               # Abbrev [2] 0x27:0xb DW_TAG_variable
-	.byte	3                               # DW_AT_name
-	.long	50                              # DW_AT_type
-	.byte	0                               # DW_AT_decl_file
-	.byte	2                               # DW_AT_decl_line
-	.byte	2                               # DW_AT_location
-	.byte	161
-	.byte	0
-	.byte	3                               # Abbrev [3] 0x32:0x5 DW_TAG_volatile_type
-	.long	55                              # DW_AT_type
-	.byte	4                               # Abbrev [4] 0x37:0x8 DW_TAG_typedef
-	.long	63                              # DW_AT_type
-	.byte	6                               # DW_AT_name
-	.byte	2                               # DW_AT_decl_file
-	.byte	27                              # DW_AT_decl_line
-	.byte	4                               # Abbrev [4] 0x3f:0x8 DW_TAG_typedef
-	.long	71                              # DW_AT_type
-	.byte	5                               # DW_AT_name
-	.byte	1                               # DW_AT_decl_file
-	.byte	45                              # DW_AT_decl_line
-	.byte	5                               # Abbrev [5] 0x47:0x4 DW_TAG_base_type
-	.byte	4                               # DW_AT_name
-	.byte	7                               # DW_AT_encoding
-	.byte	8                               # DW_AT_byte_size
-	.byte	6                               # Abbrev [6] 0x4b:0x12 DW_TAG_subprogram
-	.byte	7                               # DW_AT_name
-	.byte	0                               # DW_AT_decl_file
-	.byte	4                               # DW_AT_decl_line
-	.byte	3                               # DW_AT_calling_convention
-	.long	93                              # DW_AT_type
-                                        # DW_AT_inline
-	.byte	7                               # Abbrev [7] 0x54:0x8 DW_TAG_variable
-	.byte	11                              # DW_AT_name
-	.byte	0                               # DW_AT_decl_file
-	.byte	6                               # DW_AT_decl_line
-	.long	118                             # DW_AT_type
-	.byte	0                               # End Of Children Mark
-	.byte	8                               # Abbrev [8] 0x5d:0x5 DW_TAG_const_type
-	.long	98                              # DW_AT_type
-	.byte	4                               # Abbrev [4] 0x62:0x8 DW_TAG_typedef
-	.long	106                             # DW_AT_type
-	.byte	10                              # DW_AT_name
-	.byte	3                               # DW_AT_decl_file
-	.byte	26                              # DW_AT_decl_line
-	.byte	4                               # Abbrev [4] 0x6a:0x8 DW_TAG_typedef
-	.long	114                             # DW_AT_type
-	.byte	9                               # DW_AT_name
-	.byte	1                               # DW_AT_decl_file
-	.byte	41                              # DW_AT_decl_line
-	.byte	5                               # Abbrev [5] 0x72:0x4 DW_TAG_base_type
-	.byte	8                               # DW_AT_name
-	.byte	5                               # DW_AT_encoding
-	.byte	4                               # DW_AT_byte_size
-	.byte	4                               # Abbrev [4] 0x76:0x8 DW_TAG_typedef
-	.long	126                             # DW_AT_type
-	.byte	14                              # DW_AT_name
-	.byte	2                               # DW_AT_decl_file
-	.byte	26                              # DW_AT_decl_line
-	.byte	4                               # Abbrev [4] 0x7e:0x8 DW_TAG_typedef
-	.long	134                             # DW_AT_type
-	.byte	13                              # DW_AT_name
-	.byte	1                               # DW_AT_decl_file
-	.byte	42                              # DW_AT_decl_line
-	.byte	5                               # Abbrev [5] 0x86:0x4 DW_TAG_base_type
-	.byte	12                              # DW_AT_name
-	.byte	7                               # DW_AT_encoding
-	.byte	4                               # DW_AT_byte_size
-	.byte	9                               # Abbrev [9] 0x8a:0x24 DW_TAG_subprogram
-	.byte	1                               # DW_AT_low_pc
-	.long	.Lfunc_end0-.Lfunc_begin0       # DW_AT_high_pc
-	.byte	1                               # DW_AT_frame_base
-	.byte	87
-                                        # DW_AT_call_all_calls
-	.byte	15                              # DW_AT_name
-	.byte	0                               # DW_AT_decl_file
-	.byte	12                              # DW_AT_decl_line
-	.long	114                             # DW_AT_type
-                                        # DW_AT_external
-	.byte	10                              # Abbrev [10] 0x99:0x14 DW_TAG_inlined_subroutine
-	.long	75                              # DW_AT_abstract_origin
-	.byte	2                               # DW_AT_low_pc
-	.long	.Ltmp3-.Ltmp0                   # DW_AT_high_pc
-	.byte	0                               # DW_AT_call_file
-	.byte	14                              # DW_AT_call_line
-	.byte	5                               # DW_AT_call_column
-	.byte	11                              # Abbrev [11] 0xa6:0x6 DW_TAG_variable
-	.byte	0                               # DW_AT_location
-	.long	84                              # DW_AT_abstract_origin
-	.byte	0                               # End Of Children Mark
-	.byte	0                               # End Of Children Mark
-	.byte	0                               # End Of Children Mark
-.Ldebug_info_end0:
-	.section	.debug_str_offsets,"",@progbits
-	.long	68                              # Length of String Offsets Set
-	.short	5
-	.short	0
-.Lstr_offsets_base0:
-	.section	.debug_str,"MS",@progbits,1
-.Linfo_string0:
-	.asciz	"Ubuntu clang version 15.0.7"   # string offset=0
-.Linfo_string1:
-	.asciz	"signed_dw_op_div.c"            # string offset=28
-.Linfo_string2:
-	.asciz	""                              # string offset=47
-.Linfo_string3:
-	.asciz	"g"                             # string offset=84
-.Linfo_string4:
-	.asciz	"unsigned long"                 # string offset=86
-.Linfo_string5:
-	.asciz	"__uint64_t"                    # string offset=100
-.Linfo_string6:
-	.asciz	"uint64_t"                      # string offset=111
-.Linfo_string7:
-	.asciz	"f"                             # string offset=120
-.Linfo_string8:
-	.asciz	"int"                           # string offset=122
-.Linfo_string9:
-	.asciz	"__int32_t"                     # string offset=126
-.Linfo_string10:
-	.asciz	"int32_t"                       # string offset=136
-.Linfo_string11:
-	.asciz	"i"                             # string offset=144
-.Linfo_string12:
-	.asciz	"unsigned int"                  # string offset=146
-.Linfo_string13:
-	.asciz	"__uint32_t"                    # string offset=159
-.Linfo_string14:
-	.asciz	"uint32_t"                      # string offset=170
-.Linfo_string15:
-	.asciz	"main"                          # string offset=179
-	.section	.debug_str_offsets,"",@progbits
-	.long	.Linfo_string0
-	.long	.Linfo_string1
-	.long	.Linfo_string2
-	.long	.Linfo_string3
-	.long	.Linfo_string4
-	.long	.Linfo_string5
-	.long	.Linfo_string6
-	.long	.Linfo_string7
-	.long	.Linfo_string8
-	.long	.Linfo_string9
-	.long	.Linfo_string10
-	.long	.Linfo_string11
-	.long	.Linfo_string12
-	.long	.Linfo_string13
-	.long	.Linfo_string14
-	.long	.Linfo_string15
-	.section	.debug_addr,"",@progbits
-	.long	.Ldebug_addr_end0-.Ldebug_addr_start0 # Length of contribution
-.Ldebug_addr_start0:
-	.short	5                               # DWARF version number
-	.byte	8                               # Address size
-	.byte	0                               # Segment selector size
-.Laddr_table_base0:
-	.quad	g
-	.quad	.Lfunc_begin0
-	.quad	.Ltmp0
-.Ldebug_addr_end0:
-	.ident	"Ubuntu clang version 15.0.7"
-	.section	".note.GNU-stack","",@progbits
-	.addrsig
-	.addrsig_sym g
-	.section	.debug_line,"",@progbits
-.Lline_table_start0:
diff -ruN --strip-trailing-cr a/llvm/docs/CommandGuide/tblgen.rst b/llvm/docs/CommandGuide/tblgen.rst
--- a/llvm/docs/CommandGuide/tblgen.rst
+++ b/llvm/docs/CommandGuide/tblgen.rst
@@ -348,6 +348,14 @@
 
   Generate ``riscv_vector_builtin_cg.inc`` for Clang.
 
+.. option:: -gen-riscv-sifive-vector-builtins
+
+  Generate ``riscv_sifive_vector_builtins.inc`` for Clang.
+
+.. option:: -gen-riscv-sifive-vector-builtin-codegen
+
+  Generate ``riscv_sifive_vector_builtin_cg.inc`` for Clang.
+
 .. option:: -gen-attr-docs
 
   Generate attribute documentation.
diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/clang/BUILD.bazel b/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
--- a/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
+++ b/utils/bazel/llvm-project-overlay/clang/BUILD.bazel
@@ -228,6 +228,7 @@
     td_file = "include/clang/Basic/riscv_vector.td",
     td_srcs = [
         "include/clang/Basic/riscv_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
     ],
 )
 
@@ -241,6 +242,7 @@
     td_file = "include/clang/Basic/riscv_vector.td",
     td_srcs = [
         "include/clang/Basic/riscv_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
     ],
 )
 
@@ -254,6 +256,49 @@
     td_file = "include/clang/Basic/riscv_vector.td",
     td_srcs = [
         "include/clang/Basic/riscv_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
+    ],
+)
+
+gentbl(
+    name = "basic_riscv_sifive_vector_builtins_gen",
+    tbl_outs = [(
+        "-gen-riscv-sifive-vector-builtins",
+        "include/clang/Basic/riscv_sifive_vector_builtins.inc",
+    )],
+    tblgen = ":clang-tblgen",
+    td_file = "include/clang/Basic/riscv_sifive_vector.td",
+    td_srcs = [
+        "include/clang/Basic/riscv_sifive_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
+    ],
+)
+
+gentbl(
+    name = "basic_riscv_sifive_vector_builtin_cg_gen",
+    tbl_outs = [(
+        "-gen-riscv-sifive-vector-builtin-codegen",
+        "include/clang/Basic/riscv_sifive_vector_builtin_cg.inc",
+    )],
+    tblgen = ":clang-tblgen",
+    td_file = "include/clang/Basic/riscv_sifive_vector.td",
+    td_srcs = [
+        "include/clang/Basic/riscv_sifive_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
+    ],
+)
+
+gentbl(
+    name = "basic_riscv_sifive_vector_builtin_sema_gen",
+    tbl_outs = [(
+        "-gen-riscv-sifive-vector-builtin-sema",
+        "include/clang/Basic/riscv_sifive_vector_builtin_sema.inc",
+    )],
+    tblgen = ":clang-tblgen",
+    td_file = "include/clang/Basic/riscv_sifive_vector.td",
+    td_srcs = [
+        "include/clang/Basic/riscv_sifive_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
     ],
 )
 
@@ -486,6 +531,7 @@
         ":basic_arm_sve_typeflags_gen",
         ":basic_attr_gen",
         ":basic_internal_headers",
+        ":basic_riscv_sifive_vector_builtins_gen",
         ":basic_riscv_vector_builtin_cg_gen",
         ":basic_riscv_vector_builtins_gen",
         ":config",
@@ -929,6 +975,7 @@
         ":basic_arm_cde_sema_gen",
         ":basic_arm_sve_builtins_gen",
         ":basic_arm_sve_sema_rangechecks_gen",
+        ":basic_riscv_sifive_vector_builtin_sema_gen",
         ":basic_riscv_vector_builtin_sema_gen",
         ":edit",
         ":lex",
@@ -1530,6 +1577,7 @@
     td_file = "include/clang/Basic/riscv_vector.td",
     td_srcs = [
         "include/clang/Basic/riscv_vector.td",
+        "include/clang/Basic/riscv_vector_common.td",
     ],
 )
 
@@ -1694,6 +1742,7 @@
         ":basic",
         ":basic_arm_cde_cg_gen",
         ":basic_arm_sve_builtin_cg_gen",
+        ":basic_riscv_sifive_vector_builtin_cg_gen",
         ":basic_riscv_vector_builtin_cg_gen",
         ":driver",
         ":frontend",
